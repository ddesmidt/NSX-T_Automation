## NSX-T Creation of LS + Tier-1 + NSGroup + LB (LBS + VIP + Pool) + DFW (Section + Rule)
## Author: Dimitri Desmidt
## version 1.0
## April 2018

'''
Topology:
This Python Script creates 
    "N" = # of LS + LR + NSGroup + LB + DFW
    "M" = # of LS + LR + NSGroup + DFW
Attention: If scale is high (especially for LB) NSX-T Edge Node Baremetal might be required

                            +---------------+
                            |   Tier-0      |
                            | (pre-created) |    
                            +---------------+
                            /              \
                           /                \
                -----------                  ------------
               /                                         \
            +--------------+                            +--------------+
            |   Tier-1     |                            |   Tier-1     |
            |  (with LB)   |                            | (without LB) |
            +--------------+ xN times                   +--------------+ xM times
                    |.1                                         |.1
                    |                                           |
  Logical-Switch    |  10.x.x.0 /24           Logical-Switch    |  10.x.x.0/24
+------------------------------------|       +------------------------------------|
            (DFW 1 Section + 1Rule)                      (DFW 1 Section + 1Rule)
            (NSGroup=LS)                                 (NSGroup=LS)

Validated with: NSX-T 2.1
'''

import requests
import json
import datetime
from pyVmomi import vim
from pyVim.connect import SmartConnect, Disconnect
import vmutils
import ssl

# NSX-T information
manager_ip="10.114.213.8"
login="admin"
password="VMware1!"
tz_name="TZ-Overlay"
edge_cluster_name="EdgeBM-ClusterAA(Dimi)"
t0_name="Tier0-AA(EdgeBM_Dimi)"

number_iterations_with_lb = 2
number_iterations_without_lb = 2
prefix_name = "Python"


######################################################################################################
# Don't change things below
######################################################################################################

start_time= datetime.datetime.now()

#remove the self certificate warnings
requests.packages.urllib3.disable_warnings()

# headers for NSX-T Restful API calls
headers = {'Content-type': 'application/json', 'Accept': 'application/json'}


def digits(number, base=256):
    l = [0, 0]
    i = 0
    while number > 0:
        l[i]=(number % base)
        number = number // base
        i += 1
    return l


def nsxt_get_call (mgr, uri):
    response = requests.get('https://'+mgr+uri, verify=False, auth=(login, password), headers=headers, stream=True)
    if "20" not in str(response.status_code):
        print "GET uri " + uri + " response status code: "+str(response.status_code)
        print response.text
    #As the answer is in JSON format, create the proper object
    json_response=json.loads(response.text)
    return json_response

def nsxt_find_call (mgr, uri, name):
    json_response = nsxt_get_call (mgr, uri)
    rerun = 'true'
    object_list = []
    # Create list of elements to find
    while (rerun == 'true' and len(json_response['results']) > 0):
        for result in (json_response['results']):
            if name in result['display_name']:
                object_list.append(result)
        if ('cursor' in json_response):
            json_response = nsxt_get_call (mgr, uri,cursor=json_response['cursor'])
        else:
            rerun = 'false'
    return object_list

    
def nsxt_post_call (mgr, uri, payload):
    response = requests.post('https://'+mgr+uri, verify=False, auth=(login, password), headers=headers, stream=True, data=json.dumps(payload))
    if "20" not in str(response.status_code):
        print "POST uri " + uri + " response status code: "+str(response.status_code)
        print response.text
    #As the answer is in JSON format, create the proper object
    json_response=json.loads(response.text)
    return json_response


######
#GET TZ Overlay UUID
######
print "Getting TZ Overlay UUID"
tz = nsxt_find_call (manager_ip, '/api/v1/transport-zones', tz_name)
tz_id = tz[0]['id']
print "TZ_id = "+tz_id

        
######
#Create LR "Python_LR" connected to LS "Python_LS"
######
print "=== Creating LR + LS + NSGroup + LB + DFW"

for i in range(1, (1+number_iterations_with_lb+number_iterations_without_lb)):
    ###
    #Create LS
    ###
    ls_name = prefix_name+'_LS'+ str(i)
    payload ={'transport_zone_id': tz_id.encode('ascii','ignore'), 'replication_mode': 'MTEP', 'admin_state': 'UP', 'display_name': ls_name}
    json_response = nsxt_post_call(manager_ip, '/api/v1/logical-switches', payload)
    ls_id = json_response['id']
    
    ###
    #Create LS-Port
    ###
    payload ={'logical_switch_id': ls_id.encode('ascii','ignore'), 'admin_state': 'UP', 'description': 'LR-port'}
    json_response = nsxt_post_call(manager_ip,'/api/v1/logical-ports', payload)
    lsport_id = json_response['id']
    
    ###
    #Create LR + LR-Port
    ###
    #Create LR
    if i <= number_iterations_with_lb:
        t1_name = prefix_name+'_LR'+ str(i)+'(LB)'
    else:
        t1_name = prefix_name+'_LR'+ str(i)
    edge_cluster = nsxt_find_call (manager_ip, '/api/v1/edge-clusters', edge_cluster_name)
    edge_cluster_id = edge_cluster[0]['id']
    payload ={'resource_type': 'LogicalRouter', 'display_name': t1_name, 'router_type': 'TIER1', 'edge_cluster_id': edge_cluster_id}
    json_response = nsxt_post_call(manager_ip, '/api/v1/logical-routers', payload)
    t1_id = json_response['id']
    
    #Create LR-Port-Downlink
    ipaddr = digits(i)
    lr_ip = '10.'+str(ipaddr[1])+'.'+str(ipaddr[0])+'.1'
    payload ={'resource_type': 'LogicalRouterDownLinkPort', 'logical_router_id': t1_id, \
        'linked_logical_switch_port_id': {'target_type': 'LogicalPort', 'target_id': lsport_id}, 'subnets': [{'ip_addresses': [lr_ip], 'prefix_length': '24'}]}
    json_response = nsxt_post_call(manager_ip, '/api/v1/logical-router-ports', payload)

    #Create Tier-0 LR-Port unplugged
    t0 = nsxt_find_call (manager_ip, '/api/v1/logical-routers', t0_name)
    t0_id = t0[0]['id']
    payload ={'resource_type': 'LogicalRouterLinkPortOnTIER0', 'logical_router_id': t0_id}
    json_response = nsxt_post_call(manager_ip, '/api/v1/logical-router-ports', payload)
    t0_lrport_id = json_response['id']

    #Attach Tier-0 LR-Port to Tier-1
    payload ={'resource_type': 'LogicalRouterLinkPortOnTIER1', 'logical_router_id': t1_id, 'linked_logical_router_port_id': {'target_id': t0_lrport_id}}
    json_response = nsxt_post_call(manager_ip, '/api/v1/logical-router-ports', payload)

    
    ###
    #Create LB + NSGroup + Pool + VIP
    ###
    if i <= number_iterations_with_lb:
        #Create NSGroup
        nsgroup_name = prefix_name+'_NSGroup'+ str(i)
        payload ={'display_name': nsgroup_name, 'members': [{'resource_type': 'NSGroupSimpleExpression', 'op': 'EQUALS', \
            'target_resource': {'is_valid': 'true'},'target_type': 'LogicalSwitch', 'value': ls_id, 'target_property': 'id'}],}
        json_response = nsxt_post_call(manager_ip, '/api/v1/ns-groups', payload)
        nsgroup_id = json_response['id']
        
        #Create LB_Pool
        lbpool_name = prefix_name+'_Pool'+ str(i)
        payload ={'member_group': {'grouping_object': {'target_type': 'NSGroup', 'target_id': nsgroup_id }, 'max_ip_list_size': 0}, 'display_name': lbpool_name}
        json_response = nsxt_post_call(manager_ip, '/api/v1/loadbalancer/pools', payload)
        lbpool_id = json_response['id']
        
        #Create LB_VS
        lbvs_name = prefix_name+'_VS'+ str(i)
        lb_vip = '10.'+str(ipaddr[1])+'.'+str(ipaddr[0])+'.6'
        app_profile = nsxt_find_call (manager_ip, '/api/v1/loadbalancer/application-profiles', 'nsx-default-lb-http-profile')
        app_profile_id = app_profile[0]['id']
        
        payload ={'pool_id': lbpool_id, 'default_pool_member_port' : '80', 'application_profile_id': app_profile_id, \
            'ip_address': lb_vip, 'port': '80', 'display_name': lbvs_name}
        json_response = nsxt_post_call(manager_ip, '/api/v1/loadbalancer/virtual-servers', payload)
        lbvs_id = json_response['id']
        
        #Create LB
        lb_name = prefix_name+'_LB'+ str(i)
        payload ={'attachment': {'target_type': 'LogicalRouter', 'target_id': t1_id}, 'display_name': lb_name, 'size': 'SMALL', 'virtual_server_ids': [lbvs_id],}
        json_response = nsxt_post_call(manager_ip, '/api/v1/loadbalancer/services', payload)

    
    ###
    #Create DFW Section + Rule
    ###
    #Create DFW section
    dfwsection_name = prefix_name+'_Section'+ str(i)
    payload ={'display_name': dfwsection_name, 'section_type': 'LAYER3', 'stateful': 'true'}
    json_response = nsxt_post_call(manager_ip, '/api/v1/firewall/sections', payload)
    dfwsection_id = json_response['id']

    #Create DFW rule
    dfwrule_name = prefix_name+'_Rule1'
    dfwrule_dest = '10.'+str(ipaddr[1])+'.'+str(ipaddr[0])+'.0/24'
    payload ={'display_name': dfwrule_name, 'sources': [{'target_type': 'IPv4Address', 'target_id': dfwrule_dest}], 'ip_protocol': 'IPV4', 'action': 'ALLOW', \
        'applied_tos': [{'target_type': 'LogicalSwitch', 'target_id': ls_id}]}
    json_response = nsxt_post_call(manager_ip, '/api/v1/firewall/sections/'+dfwsection_id+'/rules', payload)


    
    if i <= number_iterations_with_lb:
        print 'created LS + LR + NSGroup + LB + DFW #' + str(i)
    else:
        print 'created LS + LR + NSGroup + DFW #' + str(i)


        
end_time= datetime.datetime.now()
print 'script started at ' + start_time.strftime("%Y-%m-%d %H:%M:%S")
print 'script ended at ' + end_time.strftime("%Y-%m-%d %H:%M:%S")
total_time = end_time - start_time
print 'total time '+str(total_time).split(".")[0]
